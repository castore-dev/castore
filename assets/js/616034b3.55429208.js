"use strict";(self.webpackChunk_castore_docs=self.webpackChunk_castore_docs||[]).push([[9149],{86724:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var r=n(52685),a=(n(27378),n(35318));const o={},i="Building your own EventStorageAdapter",s={unversionedId:"building-your-own-event-storage-adapter",id:"building-your-own-event-storage-adapter",title:"Building your own EventStorageAdapter",description:"You can build your own EventStorageAdapter class by following the EventStorageAdapter interface:",source:"@site/docs/building-your-own-event-storage-adapter.md",sourceDirName:".",slug:"/building-your-own-event-storage-adapter",permalink:"/castore/docs/building-your-own-event-storage-adapter",draft:!1,editUrl:"https://github.com/castor-dev/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/building-your-own-event-storage-adapter.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Translate your site",permalink:"/castore/docs/tutorial-extras/translate-your-site"},next:{title:"\ud83d\udd90 The 5 Rules of Event Sourcing",permalink:"/castore/docs/the-five-rules-of-event-sourcing"}},l={},p=[],u={toc:p},g="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(g,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"building-your-own-eventstorageadapter"},"Building your own EventStorageAdapter"),(0,a.kt)("p",null,"You can build your own ",(0,a.kt)("inlineCode",{parentName:"p"},"EventStorageAdapter")," class by following the ",(0,a.kt)("a",{parentName:"p",href:"../packages/core/src/storageAdapter.ts"},(0,a.kt)("inlineCode",{parentName:"a"},"EventStorageAdapter")," interface"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import type { StorageAdapter } from '@castore/core';\n\nexport class CustomStorageAdapter implements StorageAdapter {\n  getEvents: StorageAdapter['getEvents'];\n  pushEvent: StorageAdapter['pushEvent'];\n  listAggregateIds: StorageAdapter['listAggregateIds'];\n  // \ud83d\udc47 Not used for the moment\n  putSnapshot: StorageAdapter['putSnapshot'];\n  getLastSnapshot: StorageAdapter['getLastSnapshot'];\n  listSnapshots: StorageAdapter['listSnapshots'];\n\n  constructor(\n    ... // Add required inputs\n  ) {\n    // Build your adapter\n  }\n}\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"You can also take a look at the ",(0,a.kt)("a",{parentName:"p",href:"../packages/inmemory-event-storage-adapter/src/inMemory.ts"},(0,a.kt)("inlineCode",{parentName:"a"},"InMemoryStorageAdapter")," implementation")," which is quite simple.")),(0,a.kt)("p",null,"The required methods are the following:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("code",null,"getEvents ",(0,a.kt)("i",null,"((aggregateId: string, opt?: OptionsObj = ",") => Promise\\u003CResponseObj\\u003E)")),": Retrieves the events of an aggregate, ordered by `version`. Returns an empty array if no event is found for this `aggregateId`.",(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"OptionsObj")," contains the following attributes:"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("code",null,"minVersion ",(0,a.kt)("i",null,"(?number)")),": To retrieve events above a certain version"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("code",null,"maxVersion ",(0,a.kt)("i",null,"(?number)")),": To retrieve events below a certain version"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("code",null,"limit ",(0,a.kt)("i",null,"(?number)")),": Maximum number of events to retrieve"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("code",null,"reverse ",(0,a.kt)("i",null,"(?boolean = false)")),": To retrieve events in reverse order (does not require to swap `minVersion` and `maxVersion`)")),(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"ResponseObj")," contains the following attributes:"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("code",null,"events ",(0,a.kt)("i",null,"(EventDetail[])")),": The aggregate events (possibly empty)")))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const { events: allEvents } = await customStorageAdapter.getEvents(aggregateId);\n\n// \ud83d\udc47 Retrieve a range of events\nconst { events: rangedEvents } = await customStorageAdapter.getEvents(\n  aggregateId,\n  { minVersion: 2, maxVersion: 5 },\n);\n\n// \ud83d\udc47 Retrieve the last event of the aggregate\nconst { events: onlyLastEvent } = await customStorageAdapter.getEvents(\n  aggregateId,\n  { reverse: true, limit: 1 },\n);\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("code",null,"pushEvent ",(0,a.kt)("i",null,"((eventDetail: EventDetail) => Promise\\u003Cvoid\\u003E)")),": Pushes a new event to the event store.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"await customStorageAdapter.pushEvent({\n  aggregateId,\n  version: lastVersion + 1,\n  timestamp: new Date().toISOString(),\n  type: 'POKEMON_APPEARED',\n  payload,\n  metadata,\n});\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"pushEvent")," method should check at write time that an event doesn't already exist for the given ",(0,a.kt)("inlineCode",{parentName:"p"},"aggregateId")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"version"),". If one exists, it should throw a custom error implementing the ",(0,a.kt)("inlineCode",{parentName:"p"},"EventAlreadyExistsError")," interface for the corresponding ",(0,a.kt)("inlineCode",{parentName:"p"},"aggregateId")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"version"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import {\n  eventAlreadyExistsErrorCode,\n  EventAlreadyExistsError,\n} from '@castore/core';\n\nclass CustomEventAlreadyExistsError\n  extends Error\n  implements EventAlreadyExistsError\n{\n  code: typeof eventAlreadyExistsErrorCode;\n  aggregateId: string;\n  version: number;\n\n  constructor({\n    eventStoreId = '',\n    aggregateId,\n    version,\n  }: {\n    eventStoreId?: string;\n    aggregateId: string;\n    version: number;\n  }) {\n    // \ud83d\udc47 Custom error message\n    super(\n      `Event already exists for ${eventStoreId} aggregate ${aggregateId} and version ${version}`,\n    );\n\n    // \ud83d\udc47 Ensures Error is correctly handled\n    this.code = eventAlreadyExistsErrorCode;\n    this.aggregateId = aggregateId;\n    this.version = version;\n  }\n}\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"This ensures that executed ",(0,a.kt)("inlineCode",{parentName:"p"},"Commands")," are not subject to ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Race_condition"},"race conditions")," and are accordingly retried.")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("code",null,"listAggregateIds ",(0,a.kt)("i",null,"((opt?: OptionsObj = ",") => Promise\\u003CResponseObj\\u003E)")),": Retrieves the list of `aggregateId` of an event store, ordered by `timestamp` of their initial event. Returns an empty array if no aggregate is found.",(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"OptionsObj")," contains the following attributes:"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("code",null,"limit ",(0,a.kt)("i",null,"(?number)")),": Maximum number of aggregate ids to retrieve"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("code",null,"pageToken ",(0,a.kt)("i",null,"(?string)")),": To retrieve a paginated result of aggregate ids"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("code",null,"initialEventAfter ",(0,a.kt)("i",null,"(?string)")),": To retrieve aggregate ids that appeared after a certain timestamp"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("code",null,"initialEventBefore ",(0,a.kt)("i",null,"(?string)")),": To retrieve aggregate ids that appeared before a certain timestamp"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("code",null,"reverse ",(0,a.kt)("i",null,"(?boolean)")),": To retrieve the aggregate ids in reverse order")),(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"ResponseObj")," contains the following attributes:"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("code",null,"aggregateIds ",(0,a.kt)("i",null,"(string[])")),": The list of aggregate ids"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("code",null,"nextPageToken ",(0,a.kt)("i",null,"(?string)")),": A token for the next page of aggregate ids if one exists. The nextPageToken carries the previously used options, so you do not have to provide them again (though you can still do it to override them).")))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const accAggregateIds: string = [];\nconst { aggregateIds: firstPage, nextPageToken } =\n  await customStorageAdapter.listAggregateIds({ limit: 20 });\n\naccAggregateIds.push(...firstPage);\n\nif (nextPageToken) {\n  const { aggregateIds: secondPage } =\n    await customStorageAdapter.listAggregateIds({\n      pageToken: nextPageToken,\n    });\n  accAggregateIds.push(...secondPage);\n}\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("code",null,"putSnapshot ",(0,a.kt)("i",null,"((aggregate: Aggregate) => Promise\\u003Cvoid\\u003E)")),": Saves a snapshot of an aggregate.")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"\u26a0\ufe0f Snapshot methods are a work in progress. Don't use them in production yet!")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("code",null,"getLastSnapshot ",(0,a.kt)("i",null,"((aggregateId: string, opt?: OptionsObj = ",") => Promise\\u003CResponseObj\\u003E)")),": Fetches the last snapshot of an aggregate.",(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"OptionsObj")," contains the following attributes:"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("code",null,"maxVersion ",(0,a.kt)("i",null,"(?number)")),": To retrieve snapshot below a certain version")),(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"ResponseObj")," contains the following attributes:"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("code",null,"snapshot ",(0,a.kt)("i",null,"(?Aggregate)")),": The snapshot (possibly undefined)")))),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"\u26a0\ufe0f Snapshot methods are a work in progress. Don't use them in production yet!")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("code",null,"listSnapshots ",(0,a.kt)("i",null,"((aggregateId: string, opt?: OptionsObj = ",") => Promise\\u003CResponseObj\\u003E)")),": Fetches all snapshots of an aggregate.",(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"OptionsObj")," contains the following attributes:"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("code",null,"minVersion ",(0,a.kt)("i",null,"(?number)")),": To retrieve snapshots above a certain version"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("code",null,"maxVersion ",(0,a.kt)("i",null,"(?number)")),": To retrieve snapshots below a certain version"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("code",null,"limit ",(0,a.kt)("i",null,"(?number)")),": Maximum number of snapshots to retrieve"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("code",null,"reverse ",(0,a.kt)("i",null,"(?boolean = false)")),": To retrieve snapshots in reverse order (does not require to swap `minVersion` and `maxVersion`)")),(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"ResponseObj")," contains the following attributes:"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("code",null,"snapshots ",(0,a.kt)("i",null,"(Aggregate[])")),": The list of snapshots (possibly empty)")))),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"\u26a0\ufe0f Snapshot methods are a work in progress. Don't use them in production yet!")))}d.isMDXComponent=!0},35318:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var r=n(27378);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},g="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),g=p(n),c=a,m=g["".concat(l,".").concat(c)]||g[c]||d[c]||o;return n?r.createElement(m,i(i({ref:t},u),{},{components:n})):r.createElement(m,i({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[g]="string"==typeof e?e:a,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"}}]);