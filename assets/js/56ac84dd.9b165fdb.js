"use strict";(self.webpackChunk_castore_docs=self.webpackChunk_castore_docs||[]).push([[688],{80239:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>l,toc:()=>u});var r=n(52685),o=(n(27378),n(35318));const a={sidebar_position:5},i="\u270d\ufe0f Pushing events",l={unversionedId:"event-sourcing/pushing-events",id:"event-sourcing/pushing-events",title:"\u270d\ufe0f Pushing events",description:"Modifying the state of your application (i.e. pushing new events to your event stores) is done by executing commands. They typically consist in:",source:"@site/docs/3-event-sourcing/5-pushing-events.md",sourceDirName:"3-event-sourcing",slug:"/event-sourcing/pushing-events",permalink:"/castore/docs/event-sourcing/pushing-events",draft:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"\ud83d\uded2 Fetching events",permalink:"/castore/docs/event-sourcing/fetching-events"},next:{title:"\ud83d\udd17 Joining data",permalink:"/castore/docs/event-sourcing/joining-data"}},s={},u=[],p={toc:u},c="wrapper";function d(e){let{components:t,...a}=e;return(0,o.kt)(c,(0,r.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"\ufe0f-pushing-events"},"\u270d\ufe0f Pushing events"),(0,o.kt)("p",null,"Modifying the state of your application (i.e. pushing new events to your event stores) is done by executing ",(0,o.kt)("strong",{parentName:"p"},"commands"),". They typically consist in:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Fetching the required aggregates")," (if not the initial event of a new aggregate)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Validating")," that the modification is acceptable"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Pushing new events")," with incremented versions")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Command",src:n(556).Z,width:"3102",height:"1015"})),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { Command, tuple } from '@castore/core';\n\ntype Input = { name: string; level: number };\ntype Output = { pokemonId: string };\ntype Context = { generateUuid: () => string };\n\nconst catchPokemonCommand = new Command({\n  commandId: 'CATCH_POKEMON',\n  // \ud83d\udc47 \"tuple\" is needed to keep ordering in inferred type\n  requiredEventStores: tuple(pokemonsEventStore, trainersEventStore),\n  // \ud83d\udc47 Code to execute\n  handler: async (\n    commandInput: Input,\n    [pokemonsEventStore, trainersEventStore],\n    // \ud83d\udc47 Additional context arguments can be provided\n    { generateUuid }: Context,\n  ): Promise<Output> => {\n    const { name, level } = commandInput;\n    const pokemonId = generateUuid();\n\n    await pokemonsEventStore.pushEvent({\n      aggregateId: pokemonId,\n      version: 1,\n      type: 'POKEMON_CAUGHT',\n      payload: { name, level },\n    });\n\n    return { pokemonId };\n  },\n});\n")),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Note that we only provided TS types for ",(0,o.kt)("inlineCode",{parentName:"p"},"Input")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Output")," properties. That is because, as stated in the ",(0,o.kt)("a",{parentName:"p",href:"/castore/docs/introduction#-core-design"},"core design"),", ",(0,o.kt)("strong",{parentName:"p"},"Castore is meant to be as flexible as possible"),", and that includes the validation library you want to use (if any): The ",(0,o.kt)("inlineCode",{parentName:"p"},"Command")," class can be used directly if no validation is required, or implemented by ",(0,o.kt)("a",{parentName:"p",href:"/castore/docs/packages#-commands"},"other classes")," which will add run-time validation methods to it \ud83d\udc4d")),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"Commands")," handlers should NOT use ",(0,o.kt)("a",{parentName:"p",href:"/castore/docs/reacting-to-events/read-models"},"read models")," when validating that a modification is acceptable. Read models are like cache: They are not the source of truth, and may not represent the freshest state."),(0,o.kt)("p",null,"Fetching and pushing events non-simultaneously exposes your application to ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Race_condition"},"race conditions"),". To counter that, commands are designed to be retried when an ",(0,o.kt)("inlineCode",{parentName:"p"},"EventAlreadyExistsError")," is triggered (which is part of the ",(0,o.kt)("inlineCode",{parentName:"p"},"EventStorageAdapter")," interface)."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Command Retry",src:n(31296).Z,width:"1966",height:"639"})),(0,o.kt)("p",null,"Finally, Command handlers should be, as much as possible, ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Pure_function"},"pure functions"),". If they depend on impure functions like functions with unpredictable outputs (e.g. id generation), mutating effects, side effects or state dependency (e.g. external data fetching), you should pass them through the additional context arguments rather than directly importing and using them. This will make them easier to test and to re-use in different contexts, such as in the ",(0,o.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/@castore/react-visualizer"},"React Visualizer"),"."),(0,o.kt)("blockquote",null,(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("b",null,"\ud83d\udd27 Reference")),(0,o.kt)("p",null),(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Constructor:")),(0,o.kt)("ul",{parentName:"blockquote"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("code",null,"commandId ",(0,o.kt)("i",null,"(string)")),": A string identifying the command"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("code",null,"handler ",(0,o.kt)("i",null,"((input: Input, requiredEventsStores: EventStore[]) => Promise(Output))")),": The code to execute"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("code",null,"requiredEventStores ",(0,o.kt)("i",null,"(EventStore[])")),": A tuple of ",(0,o.kt)("code",null,"EventStores")," that are required by the command for read/write purposes. In TS, you should use the ",(0,o.kt)("code",null,"tuple")," util to preserve tuple ordering in the handler (",(0,o.kt)("code",null,"tuple")," doesn't mute its inputs, it simply returns them)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("code",null,"eventAlreadyExistsRetries ",(0,o.kt)("i",null,"(?number = 2)")),": Number of handler execution retries before breaking out of the retry loop (See section below on race conditions)"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("code",null,"onEventAlreadyExists ",(0,o.kt)("i",null,"(?(error: EventAlreadyExistsError, context: ContextObj) => Promise(void))")),": Optional callback to execute when an ",(0,o.kt)("code",null,"EventAlreadyExistsError")," is raised.",(0,o.kt)("p",{parentName:"li"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"EventAlreadyExistsError")," class contains the following properties:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("code",null,"eventStoreId ",(0,o.kt)("i",null,"(?string)")),": The ",(0,o.kt)("code",null,"eventStoreId")," of the aggregate on which the ",(0,o.kt)("code",null,"pushEvent")," attempt failed"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("code",null,"aggregateId ",(0,o.kt)("i",null,"(string)")),": The ",(0,o.kt)("code",null,"aggregateId")," of the aggregate"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("code",null,"version ",(0,o.kt)("i",null,"(number)")),": The ",(0,o.kt)("code",null,"version")," of the aggregate")),(0,o.kt)("p",{parentName:"li"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ContextObj")," contains the following properties:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("code",null,"attemptNumber ",(0,o.kt)("i",null,"(?number)")),": The number of handler execution attempts in the retry loop"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("code",null,"retriesLeft ",(0,o.kt)("i",null,"(?number)")),": The number of retries left before breaking out of the retry loop")))),(0,o.kt)("pre",{parentName:"blockquote"},(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { Command, tuple } from '@castore/core';\n\nconst doSomethingCommand = new Command({\n  commandId: 'DO_SOMETHING',\n  requiredEventStores: tuple(eventStore1, eventStore2),\n  handler: async (commandInput, [eventStore1, eventStore2]) => {\n    // ...do something here\n  },\n});\n")),(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Properties:")),(0,o.kt)("ul",{parentName:"blockquote"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("code",null,"commandId ",(0,o.kt)("i",null,"(string)")),": The command id")),(0,o.kt)("pre",{parentName:"blockquote"},(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const commandId = doSomethingCommand.commandId;\n// => 'DO_SOMETHING'\n")),(0,o.kt)("ul",{parentName:"blockquote"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("code",null,"requiredEventStores ",(0,o.kt)("i",null,"(EventStore[])")),": The required event stores")),(0,o.kt)("pre",{parentName:"blockquote"},(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const requiredEventStores = doSomethingCommand.requiredEventStores;\n// => [eventStore1, eventStore2]\n")),(0,o.kt)("ul",{parentName:"blockquote"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("code",null,"handler ",(0,o.kt)("i",null,"((input: Input, requiredEventsStores: EventStore[]) => Promise(Output))")),": Function to invoke the command")),(0,o.kt)("pre",{parentName:"blockquote"},(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const output = await doSomethingCommand.handler(input, [\n  eventStore1,\n  eventStore2,\n]);\n")))))}d.isMDXComponent=!0},35318:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>k});var r=n(27378);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),u=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=u(n),m=o,k=c["".concat(s,".").concat(m)]||c[m]||d[m]||a;return n?r.createElement(k,i(i({ref:t},p),{},{components:n})):r.createElement(k,i({ref:t},p))}));function k(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:o,i[1]=l;for(var u=2;u<a;u++)i[u]=n[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},556:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/command-bb1e312ea4f78508994752bcb7768037.png"},31296:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/commandRetry-1533107995be3ed70d7563603c9970a6.png"}}]);