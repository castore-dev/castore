"use strict";(self.webpackChunk_castore_docs_docusaurus=self.webpackChunk_castore_docs_docusaurus||[]).push([[849],{42910:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>i,toc:()=>u});var n=a(28427),s=(a(2784),a(30876));const o={sidebar_position:4},r="\ud83d\udcaa Advanced usage",i={unversionedId:"advanced-usage",id:"advanced-usage",title:"\ud83d\udcaa Advanced usage",description:"Event-driven architecture",source:"@site/docs/4-advanced-usage.md",sourceDirName:".",slug:"/advanced-usage",permalink:"/castore/docs/advanced-usage",draft:!1,editUrl:"https://github.com/castor-dev/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/4-advanced-usage.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"\ud83d\ude80 The Basics",permalink:"/castore/docs/the-basics"},next:{title:"\ud83d\udcd6 Resources",permalink:"/castore/docs/resources/"}},l={},u=[{value:"Event-driven architecture",id:"event-driven-architecture",level:2},{value:"<code>MessageQueue</code>",id:"messagequeue",level:2},{value:"<code>MessageQueueAdapter</code>",id:"messagequeueadapter",level:2},{value:"<code>MessageBus</code>",id:"messagebus",level:2},{value:"<code>MessageBusAdapter</code>",id:"messagebusadapter",level:2},{value:"<code>ConnectedEventStore</code>",id:"connectedeventstore",level:2},{value:"Snapshotting",id:"snapshotting",level:2},{value:"Read Models",id:"read-models",level:2}],p={toc:u},g="wrapper";function c(e){let{components:t,...o}=e;return(0,s.kt)(g,(0,n.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"-advanced-usage"},"\ud83d\udcaa Advanced usage"),(0,s.kt)("h2",{id:"event-driven-architecture"},"Event-driven architecture"),(0,s.kt)("p",null,"Event Sourcing integrates very well with ",(0,s.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Event-driven_architecture"},"event-driven architectures"),". In a traditional architecture, you would need to design your system events (or ",(0,s.kt)("strong",{parentName:"p"},"messages")," for clarity) separately from your data. With Event Sourcing, they can simply ",(0,s.kt)("strong",{parentName:"p"},"broadcast the business events you already designed"),"."),(0,s.kt)("p",null,"In Castore, we distinguish three types of message:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"AggregateExists messages")," which only carry aggregate ids (mainly for maintenance purposes)"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Notification messages")," which also carry event details"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"State-carrying messages")," which also carry their corresponding aggregates")),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Messages Types",src:a(2095).Z,width:"1133",height:"488"})),(0,s.kt)("p",null,"In Castore, they are implemented by the ",(0,s.kt)("inlineCode",{parentName:"p"},"AggregateExistsMessage"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"NotificationMessage")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"StateCarryingMessage")," TS types:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// AggregateExistsMessage\nimport type {\n  AggregateExistsMessage,\n  EventStoreAggregateExistsMessage,\n} from '@castore/core';\n\ntype PokemonAggregateExistsMessage = AggregateExistsMessage<'POKEMONS'>;\n\n// \ud83d\udc47 Equivalent to:\ntype PokemonAggregateExistsMessage = {\n  eventStoreId: 'POKEMONS';\n  aggregateId: string;\n};\n\n// // \ud83d\udc47 Also equivalent to:\ntype PokemonAggregateExistsMessage = EventStoreAggregateExistsMessage<\n  typeof pokemonsEventStore\n>;\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// NotificationMessage\nimport type {\n  NotificationMessage,\n  EventStoreNotificationMessage,\n} from '@castore/core';\n\ntype PokemonEventNotificationMessage = NotificationMessage<\n  'POKEMONS',\n  PokemonEventDetails\n>;\n\n// \ud83d\udc47 Equivalent to:\ntype PokemonEventNotificationMessage = {\n  eventStoreId: 'POKEMONS';\n  event: PokemonEventDetails;\n};\n\n// \ud83d\udc47 Also equivalent to:\ntype PokemonEventNotificationMessage = EventStoreNotificationMessage<\n  typeof pokemonsEventStore\n>;\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// StateCarryingMessage\nimport type {\n  StateCarryingMessage,\n  EventStoreStateCarryingMessage,\n} from '@castore/core';\n\ntype PokemonEventStateCarryingMessage = StateCarryingMessage<\n  'POKEMONS',\n  PokemonEventDetails,\n  PokemonAggregate\n>;\n\n// \ud83d\udc47 Equivalent to:\ntype PokemonEventStateCarryingMessage = {\n  eventStoreId: 'POKEMONS';\n  event: PokemonEventDetails;\n  aggregate: PokemonAggregate\n};\n\n// \ud83d\udc47 Also equivalent to:\ntype PokemonEventStateCarryingMessage = EventStoreStateCarryingMessage<\n  typeof pokemonsEventStore\n>;\n")),(0,s.kt)("p",null,"All types of message can be published through message channels, i.e. ",(0,s.kt)("a",{parentName:"p",href:"#--messagequeue"},"Message Queues")," or ",(0,s.kt)("a",{parentName:"p",href:"#--messagebus"},"Message Buses"),"."),(0,s.kt)("h2",{id:"messagequeue"},(0,s.kt)("inlineCode",{parentName:"h2"},"MessageQueue")),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Message_queue"},"Message Queues")," store the published messages until they are handled by a ",(0,s.kt)("strong",{parentName:"p"},"worker"),". The worker is unique and predictible. It consumes all messages indifferently of their content."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Message Queue",src:a(16565).Z,width:"2594",height:"830"})),(0,s.kt)("p",null,"You can use the ",(0,s.kt)("inlineCode",{parentName:"p"},"AggregateExistsMessageQueue"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"NotificationMessageQueue")," or ",(0,s.kt)("inlineCode",{parentName:"p"},"StateCarryingMessageQueue")," classes to implement message queues:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { NotificationMessageQueue } from '@castore/core';\n\nconst appMessageQueue = new NotificationMessageQueue({\n  messageQueueId: 'APP_MESSAGE_QUEUE',\n  sourceEventStores: [pokemonsEventStore, trainersEventStore],\n});\n\nawait appMessageQueue.publishMessage({\n  // \ud83d\udc47 Typed as NotificationMessage of one of the source event stores\n  eventStoreId: 'POKEMONS',\n  event: {\n    type: 'POKEMON_LEVELED_UP',\n    // ...\n  },\n});\n\n// Similar for AggregateExistsMessageQueue and StateCarryingMessageQueue\n")),(0,s.kt)("blockquote",null,(0,s.kt)("details",null,(0,s.kt)("summary",null,(0,s.kt)("b",null,"\ud83d\udd27 Technical description")),(0,s.kt)("p",null),(0,s.kt)("p",{parentName:"blockquote"},(0,s.kt)("strong",{parentName:"p"},"Constructor:")),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("code",null,"messageQueueId ",(0,s.kt)("i",null,"(string)")),": A string identifying the message queue"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("code",null,"sourceEventStores ",(0,s.kt)("i",null,"(EventStore[])")),": List of event stores that the message queue will broadcast events from"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("code",null,"messageQueueAdapter ",(0,s.kt)("i",null,"(?MessageChannelAdapter)")),": See section on [`MessageQueueAdapters`](#--messagequeueadapter)")),(0,s.kt)("p",{parentName:"blockquote"},(0,s.kt)("strong",{parentName:"p"},"Properties:")),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("code",null,"messageChannelId ",(0,s.kt)("i",null,"(string)")))),(0,s.kt)("pre",{parentName:"blockquote"},(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const appMessageQueueId = appMessageQueue.messageChannelId;\n// => 'APP_MESSAGE_QUEUE'\n")),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("code",null,"sourceEventStores ",(0,s.kt)("i",null,"(EventStore[])")))),(0,s.kt)("pre",{parentName:"blockquote"},(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const appMessageQueueSourceEventStores = appMessageQueue.sourceEventStores;\n// => [pokemonsEventStore, trainersEventStore...]\n")),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("code",null,"messageChannelAdapter ",(0,s.kt)("i",null,"?MessageChannelAdapter")),": See section on [`MessageQueueAdapters`](#--messagequeueadapter)")),(0,s.kt)("pre",{parentName:"blockquote"},(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const appMessageQueueAdapter = appMessageQueue.messageChannelAdapter;\n// => undefined (we did not provide one in this example)\n")),(0,s.kt)("p",{parentName:"blockquote"},"\u261d\ufe0f The ",(0,s.kt)("inlineCode",{parentName:"p"},"messageChannelAdapter")," is not read-only so you do not have to provide it right away."),(0,s.kt)("p",{parentName:"blockquote"},(0,s.kt)("strong",{parentName:"p"},"Async Methods:")),(0,s.kt)("p",{parentName:"blockquote"},"The following methods interact with the messaging solution of your application through a ",(0,s.kt)("inlineCode",{parentName:"p"},"MessageQueueAdapter"),". They will throw an ",(0,s.kt)("inlineCode",{parentName:"p"},"UndefinedMessageChannelAdapterError")," if you did not provide one."),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("code",null,"publishMessage ",(0,s.kt)("i",null,"((message: NotificationMessage | StateCarryingMessage) => Promise<void>)")),": Publish a `NotificationMessage` (for `NotificationMessageQueues`) or a `StateCarryingMessage` (for `StateCarryingMessageQueues`) to the message queue."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("code",null,"publishMessages ",(0,s.kt)("i",null,"((messages: NotificationMessage[] | StateCarryingMessage[]) => Promise<void>)")),": Publish several `NotificationMessage` (for `NotificationMessageQueues`) or several `StateCarryingMessage` (for `StateCarryingMessageQueues`) to the message queue."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("code",null,"getAggregateAndPublishMessage ",(0,s.kt)("i",null,"((message: NotificationMessage) => Promise<void>)")),": _(StateCarryingMessageQueues only)_ Append the matching aggregate (with correct version) to a `NotificationMessage` and turn it into a `StateCarryingMessage` before publishing it to the message queue. Uses the message queue event stores: Make sure that they have correct adapters set up.")),(0,s.kt)("p",{parentName:"blockquote"},(0,s.kt)("strong",{parentName:"p"},"Type Helpers:")),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("code",null,"MessageChannelMessage"),": Given a `MessageQueue`, returns the TS type of its messages")),(0,s.kt)("pre",{parentName:"blockquote"},(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import type { MessageChannelMessage } from '@castore/core';\n\ntype AppMessage = MessageChannelMessage<typeof appMessageQueue>;\n\n// \ud83d\udc47 Equivalent to:\ntype AppMessage = EventStoreNotificationMessage<\n  typeof pokemonsEventStore | typeof trainersEventStore...\n>;\n")))),(0,s.kt)("h2",{id:"messagequeueadapter"},(0,s.kt)("inlineCode",{parentName:"h2"},"MessageQueueAdapter")),(0,s.kt)("p",null,"Similarly to event stores, ",(0,s.kt)("inlineCode",{parentName:"p"},"MessageQueue")," classes provide a boilerplate-free and type-safe interface to publish messages, but are NOT responsible for actually doing so. This is the responsibility of the ",(0,s.kt)("inlineCode",{parentName:"p"},"MessageQueueAdapter"),", that will connect it to your actual messaging solution:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { EventStore } from '@castore/core';\n\nconst messageQueue = new NotificationMessageQueue({\n  ...\n  // \ud83d\udc47 Provide it in the constructor\n  messageQueueAdapter: mySuperMessageQueueAdapter,\n});\n\n// \ud83d\udc47 ...or set/switch it in context later\nmessageQueue.messageChannelAdapter = mySuperMessageQueueAdapter;\n// Named `messageChannelAdapter` as queues inherit from the `MessageChannel` class\n")),(0,s.kt)("p",null,"You can code your own ",(0,s.kt)("inlineCode",{parentName:"p"},"MessageQueueAdapter")," (simply implement the ",(0,s.kt)("inlineCode",{parentName:"p"},"MessageChannelAdapter")," interface), but we highly recommend using an off-the-shelf adapter:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"./packages/sqs-message-queue-adapter/README.md"},"SQS Message Queue Adapter")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"./packages/in-memory-message-queue-adapter/README.md"},"In-Memory Message Queue Adapter"))),(0,s.kt)("p",null,"If the messaging solution that you use is missing, feel free to create/upvote an issue, or contribute \ud83e\udd17"),(0,s.kt)("p",null,"The adapter packages will also expose useful generics to type the arguments of your queue worker. For instance:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import type {\n  SQSMessageQueueMessage,\n  SQSMessageQueueMessageBody,\n} from '@castore/sqs-message-queue-adapter';\n\nconst appMessagesWorker = async ({ Records }: SQSMessageQueueMessage) => {\n  Records.forEach(({ body }) => {\n    // \ud83d\udc47 Correctly typed!\n    const recordBody: SQSMessageQueueMessageBody<typeof appMessageQueue> =\n      JSON.parse(body);\n  });\n};\n")),(0,s.kt)("h2",{id:"messagebus"},(0,s.kt)("inlineCode",{parentName:"h2"},"MessageBus")),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern"},"Message Buses")," are used to spread messages to multiple ",(0,s.kt)("strong",{parentName:"p"},"listeners"),". Contrary to message queues, they do not store the message or wait for the listeners to respond. Often, ",(0,s.kt)("strong",{parentName:"p"},"filter patterns")," can also be used to trigger listeners or not based on the message content."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Message Bus",src:a(62207).Z,width:"2001",height:"1279"})),(0,s.kt)("p",null,"You can use the ",(0,s.kt)("inlineCode",{parentName:"p"},"AggregateExistsMessageBus"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"NotificationMessageBus")," or ",(0,s.kt)("inlineCode",{parentName:"p"},"StateCarryingMessageBus")," classes to implement message buses:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { NotificationMessageBus } from '@castore/core';\n\nconst appMessageBus = new NotificationMessageBus({\n  messageBusId: 'APP_MESSAGE_BUSES',\n  sourceEventStores: [pokemonsEventStore, trainersEventStore...],\n});\n\nawait appMessageBus.publishMessage({\n  // \ud83d\udc47 Typed as NotificationMessage of one of the source event stores\n  eventStoreId: 'POKEMONS',\n  event: {\n    type: 'POKEMON_LEVELED_UP',\n    ...\n  }\n})\n\n// Similar for AggregateExistsMessageBus and StateCarryingMessageBus\n")),(0,s.kt)("blockquote",null,(0,s.kt)("details",null,(0,s.kt)("summary",null,(0,s.kt)("b",null,"\ud83d\udd27 Technical description")),(0,s.kt)("p",null),(0,s.kt)("p",{parentName:"blockquote"},(0,s.kt)("strong",{parentName:"p"},"Constructor:")),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("code",null,"messageBusId ",(0,s.kt)("i",null,"(string)")),": A string identifying the message bus"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("code",null,"sourceEventStores ",(0,s.kt)("i",null,"(EventStore[])")),": List of event stores that the message bus will broadcast events from"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("code",null,"messageBusAdapter ",(0,s.kt)("i",null,"(?MessageChannelAdapter)")),": See section on [`MessageBusAdapters`](#--messagebusadapter)")),(0,s.kt)("p",{parentName:"blockquote"},(0,s.kt)("strong",{parentName:"p"},"Properties:")),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("code",null,"messageBusId ",(0,s.kt)("i",null,"(string)")))),(0,s.kt)("pre",{parentName:"blockquote"},(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const appMessageBusId = appMessageBus.messageBusId;\n// => 'APP_MESSAGE_BUS'\n")),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("code",null,"sourceEventStores ",(0,s.kt)("i",null,"(EventStore[])")))),(0,s.kt)("pre",{parentName:"blockquote"},(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const appMessageBusSourceEventStores = appMessageBus.sourceEventStores;\n// => [pokemonsEventStore, trainersEventStore...]\n")),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("code",null,"messageChannelAdapter ",(0,s.kt)("i",null,"?MessageChannelAdapter")),": See section on [`MessageBusAdapters`](#--messagebusadapter)")),(0,s.kt)("pre",{parentName:"blockquote"},(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const appMessageBusAdapter = appMessageBus.messageChannelAdapter;\n// => undefined (we did not provide one in this example)\n")),(0,s.kt)("p",{parentName:"blockquote"},"\u261d\ufe0f The ",(0,s.kt)("inlineCode",{parentName:"p"},"messageChannelAdapter")," is not read-only so you do not have to provide it right away."),(0,s.kt)("p",{parentName:"blockquote"},(0,s.kt)("strong",{parentName:"p"},"Async Methods:")),(0,s.kt)("p",{parentName:"blockquote"},"The following methods interact with the messaging solution of your application through a ",(0,s.kt)("inlineCode",{parentName:"p"},"MessageBusAdapter"),". They will throw an ",(0,s.kt)("inlineCode",{parentName:"p"},"UndefinedMessageChannelAdapterError")," if you did not provide one."),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("code",null,"publishMessage ",(0,s.kt)("i",null,"((message: NotificationMessage | StateCarryingMessage) => Promise<void>)")),": Publish a `NotificationMessage` (for `NotificationMessageBuses`) or a `StateCarryingMessage` (for `StateCarryingMessageBuses`) to the message bus."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("code",null,"publishMessages ",(0,s.kt)("i",null,"((messages: NotificationMessage[] | StateCarryingMessage[]) => Promise<void>)")),": Publish several `NotificationMessage` (for `NotificationMessageBuses`) or several `StateCarryingMessage` (for `StateCarryingMessageBuses`) to the message bus."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("code",null,"getAggregateAndPublishMessage ",(0,s.kt)("i",null,"((message: NotificationMessage) => Promise<void>)")),": _(StateCarryingMessageBuses only)_ Append the matching aggregate (with correct version) to a `NotificationMessage` and turn it into a `StateCarryingMessage` before publishing it to the message bus. Uses the message bus event stores: Make sure that they have correct adapters set up.")),(0,s.kt)("p",{parentName:"blockquote"},(0,s.kt)("strong",{parentName:"p"},"Type Helpers:")),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("code",null,"MessageChannelMessage"),": Given a `MessageBus`, returns the TS type of its messages")),(0,s.kt)("pre",{parentName:"blockquote"},(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import type { MessageChannelMessage } from '@castore/core';\n\ntype AppMessage = MessageChannelMessage<typeof appMessageBus>;\n\n// \ud83d\udc47 Equivalent to:\ntype AppMessage = EventStoreNotificationMessage<\n  typeof pokemonsEventStore | typeof trainersEventStore...\n>;\n")))),(0,s.kt)("h2",{id:"messagebusadapter"},(0,s.kt)("inlineCode",{parentName:"h2"},"MessageBusAdapter")),(0,s.kt)("p",null,"Similarly to event stores, ",(0,s.kt)("inlineCode",{parentName:"p"},"MessageBus")," classes provide a boilerplate-free and type-safe interface to publish messages, but are NOT responsible for actually doing so. This is the responsibility of the ",(0,s.kt)("inlineCode",{parentName:"p"},"MessageBusAdapter"),", that will connect it to your actual messaging solution:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { EventStore } from '@castore/core';\n\nconst messageBus = new NotificationMessageBus({\n  ...\n  // \ud83d\udc47 Provide it in the constructor\n  messageBusAdapter: mySuperMessageBusAdapter,\n});\n\n// \ud83d\udc47 ...or set/switch it in context later\nmessageBus.messageChannelAdapter = mySuperMessageBusAdapter;\n// Named `messageChannelAdapter` as buses inherit from the `MessageChannel` class\n")),(0,s.kt)("p",null,"You can code your own ",(0,s.kt)("inlineCode",{parentName:"p"},"MessageBusAdapter")," (simply implement the ",(0,s.kt)("inlineCode",{parentName:"p"},"MessageChannelAdapter")," interface), but we highly recommend using an off-the-shelf adapter:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"./packages/event-bridge-message-bus-adapter/README.md"},"EventBridge Message Bus Adapter")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"./packages/in-memory-message-bus-adapter/README.md"},"In-Memory Message Bus Adapter"))),(0,s.kt)("p",null,"If the messaging solution that you use is missing, feel free to create/upvote an issue, or contribute \ud83e\udd17"),(0,s.kt)("p",null,"The adapter packages will also expose useful generics to type the arguments of your bus listeners. For instance:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import type { EventBridgeMessageBusMessage } from '@castore/event-bridge-message-bus-adapter';\n\nconst pokemonMessagesListener = async (\n  // \ud83d\udc47 Specify that you only listen to the pokemonsEventStore messages\n  eventBridgeMessage: EventBridgeMessageBusMessage<\n    typeof appMessageQueue,\n    'POKEMONS'\n  >,\n) => {\n  // \ud83d\udc47 Correctly typed!\n  const message = eventBridgeMessage.detail;\n};\n")),(0,s.kt)("h2",{id:"connectedeventstore"},(0,s.kt)("inlineCode",{parentName:"h2"},"ConnectedEventStore")),(0,s.kt)("p",null,"If your storage solution exposes data streaming capabilities (such as ",(0,s.kt)("a",{parentName:"p",href:"https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html"},"DynamoDB streams"),"), you can leverage them to push your freshly written events to a message bus or queue."),(0,s.kt)("p",null,"You can also use the ",(0,s.kt)("inlineCode",{parentName:"p"},"ConnectedEventStore")," class. Its interface matches the ",(0,s.kt)("inlineCode",{parentName:"p"},"EventStore")," one, but successfully pushing a new event will automatically forward it to a message queue/bus, and pushing a event group will also automatically forward the events to their respective message queues/buses:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { ConnectedEventStore } from '@castore/core';\n\nconst connectedPokemonsEventStore = new ConnectedEventStore(\n  // \ud83d\udc47 Original event store\n  pokemonsEventStore,\n  // \ud83d\udc47 Type-safe (appMessageBus MUST be able to carry pokemon events)\n  appMessageBus,\n);\n\n// Will push the event in the event store\n// ...AND publish it to the message bus if it succeeds \ud83d\ude4c\nawait connectedPokemonsEventStore.pushEvent({\n  aggregateId: pokemonId,\n  version: 2,\n  type: 'POKEMON_LEVELED_UP',\n  ...\n});\n")),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Note that setting a connected event store ",(0,s.kt)("inlineCode",{parentName:"p"},"storageAdapter")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"onEventPushed")," properties will override those of the original event store instead.")),(0,s.kt)("p",null,"If the message bus or queue is a state-carrying one, the ",(0,s.kt)("inlineCode",{parentName:"p"},"pushEvent")," method will re-fetch the aggregate to append it to the message before publishing it. You can reduce this overhead by providing the previous aggregate as an option:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"await connectedPokemonsEventStore.pushEvent(\n  {\n    aggregateId: pokemonId,\n    version: 2,\n    ...\n  },\n  // \ud83d\udc47 Aggregate at version 1\n  { prevAggregate: pokemonAggregate },\n  // Removes the need to re-fetch \ud83d\ude4c\n);\n")),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Connected Event Store",src:a(20900).Z,width:"2870",height:"1085"})),(0,s.kt)("p",null,"Compared to data streams, connected event stores have the advantage of simplicity, performances and costs. However, they ",(0,s.kt)("strong",{parentName:"p"},"strongly decouple your storage and messaging solutions"),": Make sure to anticipate any issue that might arise (consistency, non-caught errors etc.)."),(0,s.kt)("blockquote",null,(0,s.kt)("details",null,(0,s.kt)("summary",null,(0,s.kt)("b",null,"\ud83d\udd27 Technical description")),(0,s.kt)("p",null),(0,s.kt)("p",{parentName:"blockquote"},(0,s.kt)("strong",{parentName:"p"},"Constructor:")),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("code",null,"eventStore ",(0,s.kt)("i",null,"(EventStore)")),": The event store to connect"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("code",null,"messageChannel ",(0,s.kt)("i",null,"(MessageBus | MessageQueue)")),": A message bus or queue to forward events to")),(0,s.kt)("p",{parentName:"blockquote"},(0,s.kt)("strong",{parentName:"p"},"Properties:")),(0,s.kt)("p",{parentName:"blockquote"},"A ",(0,s.kt)("inlineCode",{parentName:"p"},"ConnectedEventStore")," will implement the interface of its original ",(0,s.kt)("inlineCode",{parentName:"p"},"EventStore"),", and extend it with two additional properties:"),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("code",null,"eventStore ",(0,s.kt)("i",null,"(EventStore)")),": The original event store")),(0,s.kt)("pre",{parentName:"blockquote"},(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const eventStore = connectedPokemonsEventStore.eventStore;\n// => pokemonsEventStore\n")),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("code",null,"messageChannel ",(0,s.kt)("i",null,"(MessageBus | MessageQueue)")),": The provided message bus or queue")),(0,s.kt)("pre",{parentName:"blockquote"},(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const messageChannel = connectedPokemonsEventStore.messageChannel;\n// => appMessageBus\n")),(0,s.kt)("p",{parentName:"blockquote"},"Note that the ",(0,s.kt)("inlineCode",{parentName:"p"},"storageAdapter")," property will act as a pointer toward the original event store ",(0,s.kt)("inlineCode",{parentName:"p"},"storageAdapter"),":"),(0,s.kt)("pre",{parentName:"blockquote"},(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"originalEventStore.storageAdapter = myStorageAdapter;\nconnectedEventStore.storageAdapter; // => myStorageAdapter\n\nconnectedEventStore.storageAdapter = anotherStorageAdapter;\noriginalEventStore.storageAdapter; // => anotherStorageAdapter\n")))),(0,s.kt)("h2",{id:"snapshotting"},"Snapshotting"),(0,s.kt)("p",null,"As events pile up in your event stores, the performances and costs of your commands can become an issue."),(0,s.kt)("p",null,"One solution is to periodially persist ",(0,s.kt)("strong",{parentName:"p"},"snapshots")," of your aggregates (e.g. through a message bus listener), and only fetch them plus the subsequent events instead of all the events."),(0,s.kt)("p",null,"Snapshots are not implemented in Castore yet, but we have big plans for them, so stay tuned \ud83d\ude42"),(0,s.kt)("h2",{id:"read-models"},"Read Models"),(0,s.kt)("p",null,"Even with snapshots, using the event store for querying needs (like displaying data in a web page) would be slow and inefficient, if not impossible depending on the access pattern."),(0,s.kt)("p",null,"In Event Sourcing, it is common to use a special type of message bus listener called ",(0,s.kt)("strong",{parentName:"p"},"projections"),", responsible for maintaining data specifically designed for querying needs, called ",(0,s.kt)("strong",{parentName:"p"},"read models"),"."),(0,s.kt)("p",null,"Read models allow for faster read operations, as well as re-indexing. Keep in mind that they are ",(0,s.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Eventual_consistency"},"eventually consistent")," by design, which can be annoying in some use cases (like opening a resource page directly after its creation)."),(0,s.kt)("p",null,"Read models are not implemented in Castore yet, but we have big plans for them, so stay tuned \ud83d\ude42"))}c.isMDXComponent=!0},30876:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>d});var n=a(2784);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,s=function(e,t){if(null==e)return{};var a,n,s={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var l=n.createContext({}),u=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},p=function(e){var t=u(e.components);return n.createElement(l.Provider,{value:t},e.children)},g="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,s=e.mdxType,o=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),g=u(a),m=s,d=g["".concat(l,".").concat(m)]||g[m]||c[m]||o;return a?n.createElement(d,r(r({ref:t},p),{},{components:a})):n.createElement(d,r({ref:t},p))}));function d(e,t){var a=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var o=a.length,r=new Array(o);r[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[g]="string"==typeof e?e:s,r[1]=i;for(var u=2;u<o;u++)r[u]=a[u];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},20900:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/connectedEventStore-20889dd0f1a0c6bba3a413e188761d0e.png"},62207:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/messageBus-5b93cec889fd1288a304a936efb1eca8.png"},16565:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/messageQueue-48fb4432f031661210e3098eedb7a1c7.png"},2095:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/messageTypes-b6a28db0c33e166141c5f5d4fd936b60.png"}}]);