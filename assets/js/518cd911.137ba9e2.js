"use strict";(self.webpackChunk_castore_docs_docusaurus=self.webpackChunk_castore_docs_docusaurus||[]).push([[81],{29768:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>o,metadata:()=>i,toc:()=>p});var a=n(28427),r=(n(2784),n(30876));const o={sidebar_position:3},l="\ud83d\ude80 The Basics",i={unversionedId:"the-basics",id:"the-basics",title:"\ud83d\ude80 The Basics",description:"Events",source:"@site/docs/3-the-basics.md",sourceDirName:".",slug:"/the-basics",permalink:"/castore/docs/the-basics",draft:!1,editUrl:"https://github.com/castor-dev/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/3-the-basics.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"\ud83c\udfac Getting Started",permalink:"/castore/docs/getting-started"},next:{title:"\ud83d\udcaa Advanced usage",permalink:"/castore/docs/advanced-usage"}},s={},p=[{value:"<code>Events</code>",id:"events",level:2},{value:"<code>EventType</code>",id:"eventtype",level:2},{value:"<code>Aggregate</code>",id:"aggregate",level:2},{value:"<code>Reducer</code>",id:"reducer",level:2},{value:"<code>EventStore</code>",id:"eventstore",level:2},{value:"<code>EventStorageAdapter</code>",id:"eventstorageadapter",level:2},{value:"<code>Command</code>",id:"command",level:2},{value:"Event Groups",id:"event-groups",level:2}],u={toc:p},d="wrapper";function m(e){let{components:t,...o}=e;return(0,r.kt)(d,(0,a.Z)({},u,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"-the-basics"},"\ud83d\ude80 The Basics"),(0,r.kt)("h2",{id:"events"},(0,r.kt)("inlineCode",{parentName:"h2"},"Events")),(0,r.kt)("p",null,"Event Sourcing is all about ",(0,r.kt)("strong",{parentName:"p"},"saving changes in your application state"),". Such changes are represented by ",(0,r.kt)("strong",{parentName:"p"},"events"),", and needless to say, they are quite important \ud83d\ude43"),(0,r.kt)("p",null,"Events that concern the same entity (like a ",(0,r.kt)("inlineCode",{parentName:"p"},"Pokemon"),") are aggregated through a common id called ",(0,r.kt)("inlineCode",{parentName:"p"},"aggregateId")," (and vice versa, events that have the same ",(0,r.kt)("inlineCode",{parentName:"p"},"aggregateId")," represent changes of the same business entity). The index of an event in such a serie of events is called its ",(0,r.kt)("inlineCode",{parentName:"p"},"version"),"."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Events",src:n(80559).Z,width:"3023",height:"944"})),(0,r.kt)("p",null,"In Castore, stored events (also called ",(0,r.kt)("strong",{parentName:"p"},"event details"),") always have exactly the following properties:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"aggregateId ",(0,r.kt)("i",null,"(string)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"version ",(0,r.kt)("i",null,"(integer \u2265 1)"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"timestamp ",(0,r.kt)("i",null,"(string)")),": A date in ISO 8601 format"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"type ",(0,r.kt)("i",null,"(string)")),": A string identifying the business meaning of the event"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"payload ",(0,r.kt)("i",null,"(?any = never)")),": A payload of any type"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"metadata ",(0,r.kt)("i",null,"(?any = never)")),": Some metadata of any type")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import type { EventDetail } from '@castore/core';\n\ntype PokemonAppearedEventDetail = EventDetail<\n  'POKEMON_APPEARED',\n  { name: string; level: number },\n  { trigger?: 'random' | 'scripted' }\n>;\n\n// \ud83d\udc47 Equivalent to:\ntype PokemonAppearedEventDetail = {\n  aggregateId: string;\n  version: number;\n  timestamp: string;\n  type: 'POKEMON_APPEARED';\n  payload: { name: string; level: number };\n  metadata: { trigger?: 'random' | 'scripted' };\n};\n")),(0,r.kt)("h2",{id:"eventtype"},(0,r.kt)("inlineCode",{parentName:"h2"},"EventType")),(0,r.kt)("p",null,"Events are generally classified in ",(0,r.kt)("strong",{parentName:"p"},"events types")," (not to confuse with TS types). Castore lets you declare them via the ",(0,r.kt)("inlineCode",{parentName:"p"},"EventType")," class:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { EventType } from '@castore/core';\n\nconst pokemonAppearedEventType = new EventType<\n  'POKEMON_APPEARED',\n  { name: string; level: number },\n  { trigger?: 'random' | 'scripted' }\n>({ type: 'POKEMON_APPEARED' });\n")),(0,r.kt)("p",null,"Note that we only provided TS types for ",(0,r.kt)("inlineCode",{parentName:"p"},"payload")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"metadata")," properties. That is because, as stated in the ",(0,r.kt)("a",{parentName:"p",href:"../introduction/#-core-design"},"core design"),", ",(0,r.kt)("strong",{parentName:"p"},"Castore is meant to be as flexible as possible"),", and that includes the validation library you want to use (if any): The ",(0,r.kt)("inlineCode",{parentName:"p"},"EventType")," class can be used directly if no validation is required, or implemented by other classes which will add run-time validation methods to it \ud83d\udc4d"),(0,r.kt)("p",null,"See the following packages for examples:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"../resources/json-schema-event/"},"JSON Schema Event Type")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"../resources/zod-event/"},"Zod Event Type"))),(0,r.kt)("blockquote",null,(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("b",null,"\ud83d\udd27 Technical description")),(0,r.kt)("p",null),(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Constructor:")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"type ",(0,r.kt)("i",null,"(string)")),": The event type")),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { EventType } from '@castore/core';\n\nconst pokemonAppearedEventType = new EventType({ type: 'POKEMON_APPEARED' });\n")),(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Properties:")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"type ",(0,r.kt)("i",null,"(string)")),": The event type")),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const eventType = pokemonAppearedEventType.type;\n// => 'POKEMON_APPEARED'\n")),(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Type Helpers:")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"EventTypeDetail"),": Returns the event detail TS type of an `EventType`")),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import type { EventTypeDetail } from '@castore/core';\n\ntype PokemonAppearedEventTypeDetail = EventTypeDetail<\n  typeof pokemonAppearedEventType\n>;\n\n// \ud83d\udc47 Equivalent to:\ntype PokemonCaughtEventTypeDetail = {\n  aggregateId: string;\n  version: number;\n  timestamp: string;\n  type: 'POKEMON_APPEARED';\n  payload: { name: string; level: number };\n  metadata: { trigger?: 'random' | 'scripted' };\n};\n")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"EventTypesDetails"),": Return the events details of a list of `EventType`")),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import type { EventTypesDetails } from '@castore/core';\n\ntype PokemonEventTypeDetails = EventTypesDetails<\n  [typeof pokemonAppearedEventType, typeof pokemonCaughtEventType]\n>;\n// => EventTypeDetail<typeof pokemonAppearedEventType>\n// | EventTypeDetail<typeof pokemonCaughtEventType>\n")))),(0,r.kt)("h2",{id:"aggregate"},(0,r.kt)("inlineCode",{parentName:"h2"},"Aggregate")),(0,r.kt)("p",null,"Eventhough entities are stored as series of events, we still want to use a ",(0,r.kt)("strong",{parentName:"p"},"simpler and stable interface to represent their states at a point in time")," rather than directly using events. In Castore, it is implemented by a TS type called ",(0,r.kt)("inlineCode",{parentName:"p"},"Aggregate"),"."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"\u261d\ufe0f Think of aggregates as ",(0,r.kt)("em",{parentName:"p"},'"what the data would look like in CRUD"'))),(0,r.kt)("p",null,"In Castore, aggregates necessarily contain an ",(0,r.kt)("inlineCode",{parentName:"p"},"aggregateId")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"version")," properties (the ",(0,r.kt)("inlineCode",{parentName:"p"},"version")," of the latest ",(0,r.kt)("inlineCode",{parentName:"p"},"event"),"). But for the rest, it's up to you \ud83e\udd37\u200d\u2642\ufe0f"),(0,r.kt)("p",null,"For instance, we can include a ",(0,r.kt)("inlineCode",{parentName:"p"},"name"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"level")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"status")," properties to our ",(0,r.kt)("inlineCode",{parentName:"p"},"PokemonAggregate"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import type { Aggregate } from '@castore/core';\n\n// Represents a Pokemon at a point in time\ninterface PokemonAggregate extends Aggregate {\n  name: string;\n  level: number;\n  status: 'wild' | 'caught';\n}\n\n// \ud83d\udc47 Equivalent to:\ninterface PokemonAggregate {\n  aggregateId: string;\n  version: number;\n  name: string;\n  level: number;\n  status: 'wild' | 'caught';\n}\n")),(0,r.kt)("h2",{id:"reducer"},(0,r.kt)("inlineCode",{parentName:"h2"},"Reducer")),(0,r.kt)("p",null,"Aggregates are derived from their events by ",(0,r.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce"},"reducing them")," through a ",(0,r.kt)("inlineCode",{parentName:"p"},"reducer")," function. It defines ",(0,r.kt)("strong",{parentName:"p"},"how to update the aggregate when a new event is pushed"),":"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Aggregate",src:n(44949).Z,width:"3464",height:"831"})),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import type { Reducer } from '@castore/core';\n\nconst pokemonsReducer: Reducer<PokemonAggregate, PokemonEventDetails> = (\n  pokemonAggregate,\n  newEvent,\n) => {\n  const { version, aggregateId } = newEvent;\n\n  switch (newEvent.type) {\n    case 'POKEMON_APPEARED': {\n      const { name, level } = newEvent.payload;\n\n      // \ud83d\udc47 Return the next version of the aggregate\n      return {\n        aggregateId,\n        version,\n        name,\n        level,\n        status: 'wild',\n      };\n    }\n    case 'POKEMON_CAUGHT':\n      return { ...pokemonAggregate, version, status: 'caught' };\n    case 'POKEMON_LEVELED_UP':\n      return {\n        ...pokemonAggregate,\n        version,\n        level: pokemonAggregate.level + 1,\n      };\n  }\n};\n\nconst myPikachuAggregate: PokemonAggregate =\n  myPikachuEvents.reduce(pokemonsReducer);\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"\u261d\ufe0f Aggregates are always ",(0,r.kt)("strong",{parentName:"p"},"computed on the fly"),", and NOT stored. Changing them does not require any data migration whatsoever.")),(0,r.kt)("h2",{id:"eventstore"},(0,r.kt)("inlineCode",{parentName:"h2"},"EventStore")),(0,r.kt)("p",null,"Once you've defined your ",(0,r.kt)("a",{parentName:"p",href:"#eventtype"},"event types")," and how to ",(0,r.kt)("a",{parentName:"p",href:"#reducer"},"aggregate")," them, you can bundle them together in an ",(0,r.kt)("inlineCode",{parentName:"p"},"EventStore")," class."),(0,r.kt)("p",null,"Each event store in your application represents a business entity. Think of event stores as ",(0,r.kt)("em",{parentName:"p"},'"what tables would be in CRUD"'),", except that instead of directly updating data, you just append new events to it!"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Event Store",src:n(28615).Z,width:"3580",height:"1378"})),(0,r.kt)("p",null,"In Castore, ",(0,r.kt)("inlineCode",{parentName:"p"},"EventStore")," classes are NOT responsible for actually storing data (this will come with ",(0,r.kt)("a",{parentName:"p",href:"#eventstorageadapter"},"event storage adapters"),"). But rather to provide a boilerplate-free and type-safe interface to perform many actions such as:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Listing aggregate ids"),(0,r.kt)("li",{parentName:"ul"},"Accessing events of an aggregate"),(0,r.kt)("li",{parentName:"ul"},"Building an aggregate with the reducer"),(0,r.kt)("li",{parentName:"ul"},"Pushing new events etc...")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { EventStore } from '@castore/core';\n\nconst pokemonsEventStore = new EventStore({\n  eventStoreId: 'POKEMONS',\n  eventStoreEvents: [\n    pokemonAppearedEventType,\n    pokemonCaughtEventType,\n    pokemonLeveledUpEventType,\n    ...\n  ],\n  reduce: pokemonsReducer,\n});\n// ...and that's it \ud83e\udd73\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"\u261d\ufe0f The ",(0,r.kt)("inlineCode",{parentName:"p"},"EventStore")," class is the heart of Castore, it even gave it its name!")),(0,r.kt)("blockquote",null,(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("b",null,"\ud83d\udd27 Technical description")),(0,r.kt)("p",null),(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Constructor:")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"eventStoreId ",(0,r.kt)("i",null,"(string)")),": A string identifying the event store"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"eventStoreEvents ",(0,r.kt)("i",null,"(EventType[])")),": The list of event types in the event store"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"reduce ",(0,r.kt)("i",null,"(EventType[])")),": A [reducer function](#--reducer) that can be applied to the store event types"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"onEventPushed ",(0,r.kt)("i",null,"(?(pushEventResponse: PushEventResponse => Promise<void>))")),": To run a callback after events are pushed (input is exactly the return value of the `pushEvent` method)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"storageAdapter ",(0,r.kt)("i",null,"(?EventStorageAdapter)")),": See [`EventStorageAdapter`](#--eventstorageadapter)")),(0,r.kt)("p",{parentName:"blockquote"},"\u261d\ufe0f The return type of the ",(0,r.kt)("inlineCode",{parentName:"p"},"reducer")," is used to infer the ",(0,r.kt)("inlineCode",{parentName:"p"},"Aggregate")," type of the ",(0,r.kt)("inlineCode",{parentName:"p"},"EventStore"),", so it is important to type it explicitely."),(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Properties:")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"eventStoreId ",(0,r.kt)("i",null,"(string)")))),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const pokemonsEventStoreId = pokemonsEventStore.eventStoreId;\n// => 'POKEMONS'\n")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"eventStoreEvents ",(0,r.kt)("i",null,"(EventType[])")))),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const pokemonsEventStoreEvents = pokemonsEventStore.eventStoreEvents;\n// => [pokemonAppearedEventType, pokemonCaughtEventType...]\n")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"reduce ",(0,r.kt)("i",null,"((Aggregate, EventType) => Aggregate)")))),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const reducer = pokemonsEventStore.reduce;\n// => pokemonsReducer\n")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"onEventPushed ",(0,r.kt)("i",null,"(?(pushEventResponse: PushEventResponse) => Promise<void>)")),": The callback to run after events are pushed")),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const onEventPushed = pokemonsEventStore.onEventPushed;\n// => undefined (we did not provide one in this example)\n")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"storageAdapter ",(0,r.kt)("i",null,"?EventStorageAdapter")),": See [`EventStorageAdapter`](#--eventstorageadapter)")),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const storageAdapter = pokemonsEventStore.storageAdapter;\n// => undefined (we did not provide one in this example)\n")),(0,r.kt)("p",{parentName:"blockquote"},"\u261d\ufe0f The ",(0,r.kt)("inlineCode",{parentName:"p"},"storageAdapter")," is not read-only so you do not have to provide it right away."),(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Sync Methods:")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"getStorageAdapter ",(0,r.kt)("i",null,"(() => EventStorageAdapter)")),": Returns the event store event storage adapter if it exists. Throws an `UndefinedStorageAdapterError` if it doesn't.")),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { UndefinedStorageAdapterError } from '@castore/core';\n\nexpect(() => pokemonsEventStore.getStorageAdapter()).toThrow(\n  new UndefinedStorageAdapterError({ eventStoreId: 'POKEMONS' }),\n);\n// => true\n")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"buildAggregate ",(0,r.kt)("i",null,"((eventDetails: EventDetail[], initialAggregate?: Aggregate) => Aggregate | undefined)")),": Applies the event store reducer to a serie of events.")),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const myPikachuAggregate = pokemonsEventStore.buildAggregate(myPikachuEvents);\n")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"groupEvent ",(0,r.kt)("i",null,"((eventDetail: EventDetail, opt?: OptionsObj = ",") => GroupedEvent)")),": See [Event Groups](#event-groups).")),(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Async Methods:")),(0,r.kt)("p",{parentName:"blockquote"},"The following methods interact with the data layer of your event store through its ",(0,r.kt)("a",{parentName:"p",href:"#--eventstorageadapter"},(0,r.kt)("inlineCode",{parentName:"a"},"EventStorageAdapter")),". They will throw an ",(0,r.kt)("inlineCode",{parentName:"p"},"UndefinedStorageAdapterError")," if you did not provide one."),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"getEvents ",(0,r.kt)("i",null,"((aggregateId: string, opt?: OptionsObj = ",") => Promise<ResponseObj>)")),": Retrieves the events of an aggregate, ordered by `version`. Returns an empty array if no event is found for this `aggregateId`.",(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"OptionsObj")," contains the following properties:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"minVersion ",(0,r.kt)("i",null,"(?number)")),": To retrieve events above a certain version"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"maxVersion ",(0,r.kt)("i",null,"(?number)")),": To retrieve events below a certain version"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"limit ",(0,r.kt)("i",null,"(?number)")),": Maximum number of events to retrieve"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"reverse ",(0,r.kt)("i",null,"(?boolean = false)")),": To retrieve events in reverse order (does not require to swap `minVersion` and `maxVersion`)")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"ResponseObj")," contains the following properties:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"events ",(0,r.kt)("i",null,"(EventDetail[])")),": The aggregate events (possibly empty)")))),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { events: allEvents } = await pokemonsEventStore.getEvents(myPikachuId);\n// => typed as PokemonEventDetail[] \ud83d\ude4c\n\n// \ud83d\udc47 Retrieve a range of events\nconst { events: rangedEvents } = await pokemonsEventStore.getEvents(\n  myPikachuId,\n  {\n    minVersion: 2,\n    maxVersion: 5,\n  },\n);\n\n// \ud83d\udc47 Retrieve the last event of the aggregate\nconst { events: onlyLastEvent } = await pokemonsEventStore.getEvents(\n  myPikachuId,\n  {\n    reverse: true,\n    limit: 1,\n  },\n);\n")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"getAggregate ",(0,r.kt)("i",null,"((aggregateId: string, opt?: OptionsObj = ",") => Promise<ResponseObj>)")),": Retrieves the events of an aggregate and build it.",(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"OptionsObj")," contains the following properties:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"maxVersion ",(0,r.kt)("i",null,"(?number)")),": To retrieve aggregate below a certain version")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"ResponseObj")," contains the following properties:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"aggregate ",(0,r.kt)("i",null,"(?Aggregate)")),": The aggregate (possibly `undefined`)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"events ",(0,r.kt)("i",null,"(EventDetail[])")),": The aggregate events (possibly empty)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"lastEvent ",(0,r.kt)("i",null,"(?EventDetail)")),": The last event (possibly `undefined`)")))),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { aggregate: myPikachu } = await pokemonsEventStore.getAggregate(\n  myPikachuId,\n);\n// => typed as PokemonAggregate | undefined \ud83d\ude4c\n\n// \ud83d\udc47 Retrieve an aggregate below a certain version\nconst { aggregate: pikachuBelowVersion5 } =\n  await pokemonsEventStore.getAggregate(myPikachuId, { maxVersion: 5 });\n\n// \ud83d\udc47 Returns the events if you need them\nconst { aggregate, events } = await pokemonsEventStore.getAggregate(\n  myPikachuId,\n);\n")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"getExistingAggregate ",(0,r.kt)("i",null,"((aggregateId: string, opt?: OptionsObj = ",") => Promise<ResponseObj>)")),": Same as `getAggregate` method, but ensures that the aggregate exists. Throws an `AggregateNotFoundError` if no event is found for this `aggregateId`.")),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { AggregateNotFoundError } from '@castore/core';\n\nexpect(async () =>\n  pokemonsEventStore.getExistingAggregate(unexistingId),\n).resolves.toThrow(\n  new AggregateNotFoundError({\n    eventStoreId: 'POKEMONS',\n    aggregateId: unexistingId,\n  }),\n);\n// true\n\nconst { aggregate } = await pokemonsEventStore.getAggregate(aggregateId);\n// => 'aggregate' and 'lastEvent' are always defined \ud83d\ude4c\n")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"pushEvent ",(0,r.kt)("i",null,"((eventDetail: EventDetail, opt?: OptionsObj = ",") => Promise<ResponseObj>)")),": Pushes a new event to the event store. The `timestamp` is optional (we keep it available as it can be useful in tests & migrations). If not provided, it is automatically set as `new Date().toISOString()`. Throws an `EventAlreadyExistsError` if an event already exists for the corresponding `aggregateId` and `version`.",(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"OptionsObj")," contains the following properties:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"prevAggregate ",(0,r.kt)("i",null,"(?Aggregate)")),": The aggregate at the current version, i.e. before having pushed the event. Can be useful in some cases like when using the [`ConnectedEventStore` class](#--connectedeventstore)")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"ResponseObj")," contains the following properties:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"event ",(0,r.kt)("i",null,"(EventDetail)")),": The complete event (includes the `timestamp`)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"nextAggregate ",(0,r.kt)("i",null,"(?Aggregate)")),": The aggregate at the new version, i.e. after having pushed the event. Returned only if the event is an initial event, if the `prevAggregate` option was provided, or when using a [`ConnectedEventStore` class](#--connectedeventstore) connected to a [state-carrying message bus or queue](#--event-driven-architecture)")))),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { event: completeEvent, nextAggregate } =\n  await pokemonsEventStore.pushEvent(\n    {\n      aggregateId: myPikachuId,\n      version: lastVersion + 1,\n      type: 'POKEMON_LEVELED_UP', // <= event type is correctly typed \ud83d\ude4c\n      payload, // <= payload is typed according to the provided event type \ud83d\ude4c\n      metadata, // <= same goes for metadata \ud83d\ude4c\n      // timestamp is optional\n    },\n    // Not required - Can be useful in some cases\n    { prevAggregate },\n  );\n")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"listAggregateIds ",(0,r.kt)("i",null,"((opt?: OptionsObj = ",") => Promise<ResponseObj>)")),": Retrieves the list of `aggregateId` of an event store, ordered by the `timestamp` of their initial event. Returns an empty array if no aggregate is found.",(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"OptionsObj")," contains the following properties:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"limit ",(0,r.kt)("i",null,"(?number)")),": Maximum number of aggregate ids to retrieve"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"initialEventAfter ",(0,r.kt)("i",null,"(?string)")),": To retrieve aggregate ids that appeared after a certain timestamp"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"initialEventBefore ",(0,r.kt)("i",null,"(?string)")),": To retrieve aggregate ids that appeared before a certain timestamp"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"reverse ",(0,r.kt)("i",null,"(?boolean)")),": To retrieve the aggregate ids in reverse order"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"pageToken ",(0,r.kt)("i",null,"(?string)")),": To retrieve a paginated result of aggregate ids")),(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"ResponseObj")," contains the following properties:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"aggregateIds ",(0,r.kt)("i",null,"(string[])")),": The list of aggregate ids"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"nextPageToken ",(0,r.kt)("i",null,"(?string)")),": A token for the next page of aggregate ids if one exists. The nextPageToken carries the previously used options, so you do not have to provide them again (though you can still do it to override them).")))),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const accAggregateIds: string = [];\nconst { aggregateIds: firstPage, nextPageToken } =\n  await pokemonsEventStore.listAggregateIds({ limit: 20 });\n\naccAggregateIds.push(...firstPage);\n\nif (nextPageToken) {\n  const { aggregateIds: secondPage } =\n    await pokemonsEventStore.listAggregateIds({\n      // \ud83d\udc47 Previous limit of 20 is passed through the page token\n      pageToken: nextPageToken,\n    });\n  accAggregateIds.push(...secondPage);\n}\n")),(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Type Helpers:")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"EventStoreId"),": Returns the `EventStore` id")),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import type { EventStoreId } from '@castore/core';\n\ntype PokemonsEventStoreId = EventStoreId<typeof pokemonsEventStore>;\n// => 'POKEMONS'\n")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"EventStoreEventsTypes"),": Returns the `EventStore` list of events types")),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import type { EventStoreEventsTypes } from '@castore/core';\n\ntype PokemonEventTypes = EventStoreEventsTypes<typeof pokemonsEventStore>;\n// => [typeof pokemonAppearedEventType, typeof pokemonCaughtEventType...]\n")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"EventStoreEventsDetails"),": Returns the union of all the `EventStore` possible events details")),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import type { EventStoreEventsDetails } from '@castore/core';\n\ntype PokemonEventDetails = EventStoreEventsDetails<typeof pokemonsEventStore>;\n// => EventTypeDetail<typeof pokemonAppearedEventType>\n// | EventTypeDetail<typeof pokemonCaughtEventType>\n// | ...\n")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"EventStoreReducer"),": Returns the `EventStore` reducer")),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import type { EventStoreReducer } from '@castore/core';\n\ntype PokemonsReducer = EventStoreReducer<typeof pokemonsEventStore>;\n// => Reducer<PokemonAggregate, PokemonEventDetails>\n")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"EventStoreAggregate"),": Returns the `EventStore` aggregate")),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import type { EventStoreAggregate } from '@castore/core';\n\ntype SomeAggregate = EventStoreAggregate<typeof pokemonsEventStore>;\n// => PokemonAggregate\n")))),(0,r.kt)("h2",{id:"eventstorageadapter"},(0,r.kt)("inlineCode",{parentName:"h2"},"EventStorageAdapter")),(0,r.kt)("p",null,"For the moment, we didn't provide any actual way to store our events data. This is the responsibility of the ",(0,r.kt)("inlineCode",{parentName:"p"},"EventStorageAdapter")," class."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { EventStore } from '@castore/core';\n\nconst pokemonsEventStore = new EventStore({\n  eventStoreId: 'POKEMONS',\n  eventTypes: pokemonEventTypes,\n  reduce: pokemonsReducer,\n  // \ud83d\udc47 Provide it in the constructor\n  storageAdapter: mySuperStorageAdapter,\n});\n\n// \ud83d\udc47 ...or set/switch it in context later\npokemonsEventStore.storageAdapter = mySuperStorageAdapter;\n")),(0,r.kt)("p",null,"You can choose to ",(0,r.kt)("a",{parentName:"p",href:"../additional-docs/building-your-own-event-storage-adapter/"},"build an event storage adapter")," that suits your usage. However, we highly recommend using an off-the-shelf adapter:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"../resources/dynamodb-event-storage-adapter/"},"DynamoDB Event Storage Adapter")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"../resources/redux-event-storage-adapter/"},"Redux Event Storage Adapter")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"../resources/inmemory-event-storage-adapter/"},"In-Memory Event Storage Adapter"))),(0,r.kt)("p",null,"If the storage solution that you use is missing, feel free to create/upvote an issue, or contribute \ud83e\udd17"),(0,r.kt)("h2",{id:"command"},(0,r.kt)("inlineCode",{parentName:"h2"},"Command")),(0,r.kt)("p",null,"Modifying the state of your application (i.e. pushing new events to your event stores) is done by executing ",(0,r.kt)("strong",{parentName:"p"},"commands"),". They typically consist in:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Fetching the required aggregates (if not the initial event of a new aggregate)"),(0,r.kt)("li",{parentName:"ul"},"Validating that the modification is acceptable"),(0,r.kt)("li",{parentName:"ul"},"Pushing new events with incremented versions")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Command",src:n(32853).Z,width:"3102",height:"1015"})),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Command, tuple } from '@castore/core';\n\ntype Input = { name: string; level: number };\ntype Output = { pokemonId: string };\ntype Context = { generateUuid: () => string };\n\nconst catchPokemonCommand = new Command({\n  commandId: 'CATCH_POKEMON',\n  // \ud83d\udc47 \"tuple\" is needed to keep ordering in inferred type\n  requiredEventStores: tuple(pokemonsEventStore, trainersEventStore),\n  // \ud83d\udc47 Code to execute\n  handler: async (\n    commandInput: Input,\n    [pokemonsEventStore, trainersEventStore],\n    // \ud83d\udc47 Additional context arguments can be provided\n    { generateUuid }: Context,\n  ): Promise<Output> => {\n    const { name, level } = commandInput;\n    const pokemonId = generateUuid();\n\n    await pokemonsEventStore.pushEvent({\n      aggregateId: pokemonId,\n      version: 1,\n      type: 'POKEMON_CAUGHT',\n      payload: { name, level },\n    });\n\n    return { pokemonId };\n  },\n});\n")),(0,r.kt)("p",null,"Note that we only provided TS types for ",(0,r.kt)("inlineCode",{parentName:"p"},"Input")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Output")," properties. That is because, as stated in the ",(0,r.kt)("a",{parentName:"p",href:"../introduction/#-core-design"},"core design"),", ",(0,r.kt)("strong",{parentName:"p"},"Castore is meant to be as flexible as possible"),", and that includes the validation library you want to use (if any): The ",(0,r.kt)("inlineCode",{parentName:"p"},"Command")," class can be used directly if no validation is required, or implemented by other classes which will add run-time validation methods to it \ud83d\udc4d"),(0,r.kt)("p",null,"See the following packages for examples:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"../resources/json-schema-command/"},"JSON Schema Command Type"))),(0,r.kt)("blockquote",null,(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("b",null,"\ud83d\udd27 Technical description")),(0,r.kt)("p",null),(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Constructor:")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"commandId ",(0,r.kt)("i",null,"(string)")),": A string identifying the command"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"handler ",(0,r.kt)("i",null,"((input: Input, requiredEventsStores: EventStore[]) => Promise<Output>)")),": The code to execute"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"requiredEventStores ",(0,r.kt)("i",null,"(EventStore[])")),": A tuple of `EventStores` that are required by the command for read/write purposes. In TS, you should use the `tuple` util to preserve tuple ordering in the handler (`tuple` doesn't mute its input, it simply returns them)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"eventAlreadyExistsRetries ",(0,r.kt)("i",null,"(?number = 2)")),": Number of handler execution retries before breaking out of the retry loop (See section below on race conditions)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"onEventAlreadyExists ",(0,r.kt)("i",null,"(?(error: EventAlreadyExistsError, context: ContextObj) => Promise<void>)")),": Optional callback to execute when an `EventAlreadyExistsError` is raised.",(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"EventAlreadyExistsError")," class contains the following properties:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"eventStoreId ",(0,r.kt)("i",null,"(?string)")),": The `eventStoreId` of the aggregate on which the `pushEvent` attempt failed"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"aggregateId ",(0,r.kt)("i",null,"(string)")),": The `aggregateId` of the aggregate"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"version ",(0,r.kt)("i",null,"(number)")),": The `version` of the aggregate")),(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ContextObj")," contains the following properties:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"attemptNumber ",(0,r.kt)("i",null,"(?number)")),": The number of handler execution attempts in the retry loop"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"retriesLeft ",(0,r.kt)("i",null,"(?number)")),": The number of retries left before breaking out of the retry loop")))),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Command, tuple } from '@castore/core';\n\nconst doSomethingCommand = new Command({\n  commandId: 'DO_SOMETHING',\n  requiredEventStores: tuple(eventStore1, eventStore2),\n  handler: async (commandInput, [eventStore1, eventStore2]) => {\n    // ...do something here\n  },\n});\n")),(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Properties:")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"commandId ",(0,r.kt)("i",null,"(string)")),": The command id")),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const commandId = doSomethingCommand.commandId;\n// => 'DO_SOMETHING'\n")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"requiredEventStores ",(0,r.kt)("i",null,"(EventStore[])")),": The required event stores")),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const requiredEventStores = doSomethingCommand.requiredEventStores;\n// => [eventStore1, eventStore2]\n")),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("code",null,"handler ",(0,r.kt)("i",null,"((input: Input, requiredEventsStores: EventStore[]) => Promise<Output>)")),": Function to invoke the command")),(0,r.kt)("pre",{parentName:"blockquote"},(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const output = await doSomethingCommand.handler(input, [\n  eventStore1,\n  eventStore2,\n]);\n")))),(0,r.kt)("p",null,"A few notes on commands handlers:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"Commands")," handlers should NOT use ",(0,r.kt)("a",{parentName:"p",href:"../advanced-usage/#read-models"},"read models")," when validating that a modification is acceptable. Read models are like cache: They are not the source of truth, and may not represent the freshest state.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Fetching and pushing events non-simultaneously exposes your application to ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Race_condition"},"race conditions"),". To counter that, commands are designed to be retried when an ",(0,r.kt)("inlineCode",{parentName:"p"},"EventAlreadyExistsError")," is triggered (which is part of the ",(0,r.kt)("inlineCode",{parentName:"p"},"EventStorageAdapter")," interface)."))),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Command Retry",src:n(20481).Z,width:"1966",height:"639"})),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Finally, Command handlers should be, as much as possible, ",(0,r.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Pure_function"},"pure functions"),". If it depends on impure functions like functions with unpredictable outputs (like id generation), mutating effects, side effects or state dependency (like external data fetching), you should pass them through the additional context arguments rather than directly importing and using them. This will make them easier to test and to re-use in different contexts, such as in the ",(0,r.kt)("a",{parentName:"li",href:"../resources/react-visualizer/"},"React Visualizer"),".")),(0,r.kt)("h2",{id:"event-groups"},"Event Groups"),(0,r.kt)("p",null,"Some commands can have an effect on several event stores, or on several aggregates of the same event store. For instance, the ",(0,r.kt)("inlineCode",{parentName:"p"},"CATCH_POKEMON")," command could write both a ",(0,r.kt)("inlineCode",{parentName:"p"},"CAUGHT_BY_TRAINER")," event on a pokemon aggregate (changing its ",(0,r.kt)("inlineCode",{parentName:"p"},"status")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"'caught'"),") and a ",(0,r.kt)("inlineCode",{parentName:"p"},"POKEMON_CAUGHT")," event on a trainer aggregate (appending the ",(0,r.kt)("inlineCode",{parentName:"p"},"pokemonId")," to its ",(0,r.kt)("inlineCode",{parentName:"p"},"pokedex"),")."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Event Group",src:n(43852).Z,width:"3023",height:"2149"})),(0,r.kt)("p",null,"To not have your application in a corrupt state, it's important to make sure that ",(0,r.kt)("strong",{parentName:"p"},"all those events are pushed or none"),". In Castore, this can be done through the ",(0,r.kt)("strong",{parentName:"p"},"event groups")," API:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"You can use the ",(0,r.kt)("inlineCode",{parentName:"li"},"groupEvent")," method to build an array of events that are to be pushed together. It has the same input interface as ",(0,r.kt)("inlineCode",{parentName:"li"},"pushEvent")," but synchronously returns a ",(0,r.kt)("inlineCode",{parentName:"li"},"GroupedEvent")," class."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"EventStore")," class exposes a static ",(0,r.kt)("inlineCode",{parentName:"li"},"pushEventGroup")," method that can be used to effectively push this event group.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"await EventStore.pushEventGroup(\n  pokemonsEventStore.groupEvent({\n    // \ud83d\udc47 Correctly typed\n    aggregateId: 'pikachu1',\n    type: 'CAUGHT_BY_TRAINER',\n    payload: { trainerId: 'ashKetchum' },\n    ...\n  }),\n  trainersEventStore.groupEvent({\n    aggregateId: 'ashKetchum',\n    type: 'POKEMON_CAUGHT',\n    payload: { pokemonId: 'pikachu1' },\n    ...\n  }),\n);\n")),(0,r.kt)("p",null,"Like the ",(0,r.kt)("inlineCode",{parentName:"p"},"pushEvent")," API, event groups are designed to throw an ",(0,r.kt)("inlineCode",{parentName:"p"},"EventAlreadyExistsError")," if the transaction has failed, making sure that commands are retried as expected when race conditions arise."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"\u261d\ufe0f When pushing event groups on several event stores, they must use the same type of event storage adapters."),(0,r.kt)("p",{parentName:"blockquote"},"\u261d\ufe0f Also, be aware of technical constraints of your event storage solution. For instance, the ",(0,r.kt)("a",{parentName:"p",href:"../resources/dynamodb-event-storage-adapter/"},(0,r.kt)("inlineCode",{parentName:"a"},"DynamoDBEventStorageAdapter")),"'s implementation is based on ",(0,r.kt)("a",{parentName:"p",href:"https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/transaction-apis.html"},"DynamoDB transactions"),", which means that the event stores tables must be in the same region, and that a groups cannot contain more than 100 events.")))}m.isMDXComponent=!0},30876:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>c});var a=n(2784);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=p(n),g=r,c=d["".concat(s,".").concat(g)]||d[g]||m[g]||o;return n?a.createElement(c,l(l({ref:t},u),{},{components:n})):a.createElement(c,l({ref:t},u))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,l=new Array(o);l[0]=g;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[d]="string"==typeof e?e:r,l[1]=i;for(var p=2;p<o;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},44949:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/aggregate-a47cae5b3c69b9a4f068da7a644e57aa.png"},32853:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/command-bb1e312ea4f78508994752bcb7768037.png"},20481:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/commandRetry-1533107995be3ed70d7563603c9970a6.png"},43852:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/eventGroup-ed7e6003ee942dd66855b39b03d5193a.png"},28615:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/eventStore-03b7f1a66b58bedf12366148fc281365.png"},80559:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/events-d741b94c2d155521294b5e634f08b3f0.png"}}]);